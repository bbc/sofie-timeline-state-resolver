#!/usr/bin/env node
/* eslint-disable */

import { compile } from 'json-schema-to-typescript'
import * as fs from 'fs/promises'
import * as path from 'path'
import meow from 'meow'
import { createRequire } from 'module'

/** ********************************************************
 *
 * This script goes through the json-schemas of all devices (located under /$schemas )
 * and auto-generates types for those schemas
 *
 ***********************************************************/

const cli = meow(
	`
	Tool to generate typescript types from tsr device json schemas
	It is recommended to run this script on the output of the "tsr-schema-deref" script

	Usage
		$ tsr-schema-types <search-path> <output-path>

	Examples
		$ tsr-schema-types ./src/$schemas/generated ./src/generated/types
`,
	{
		importMeta: import.meta,
		flags: {
			isMainRepository: {
				type: 'boolean',
				default: false,
				description: 'Set to true if running in the main repository',
			},
		},
	}
)

const searchPath = cli.input[0]
const outputPath = cli.input[1]
const isMainRepository = cli.flags.isMainRepository

if (!searchPath || !outputPath) {
	cli.showHelp()
	process.exit(1)
}

const BANNER =
	'/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and re-run the "tsr-schema-types" tool to regenerate this file.\n */\n'

let hadError = false

const capitalise = (s) => {
	if (!s) return s
	const base = s.slice(0, 1).toUpperCase() + s.slice(1)

	// replace `_a` and `-a` with `A`
	return base.replace(/[_|-][a-z]/gi, (v) => {
		return v.slice(1).toUpperCase()
	})
}
const toConstantCase = (s) => {
	if (!s) return s

	return (
		s
			// Insert underscore before uppercase letters (for camelCase)
			.replace(/([a-z])([A-Z])/g, '$1_$2')
			// Replace hyphens with underscores
			.replace(/-/g, '_')
			// Convert to uppercase
			.toUpperCase()
	)
}
const toTitleCase = (s) => {
	if (!s) return s

	return (
		s
			// First handle underscores and hyphens by replacing them with spaces
			.replace(/[_-]/g, ' ')
			// Insert space before uppercase letters that follow lowercase letters (camelCase)
			.replace(/([a-z])([A-Z])/g, '$1 $2')
			// Insert space before uppercase letters that are followed by lowercase letters (acronyms like PTZ)
			.replace(/([A-Z])([A-Z][a-z])/g, '$1 $2')
			// Capitalize first letter of each word
			.replace(/\b\w/g, (char) => char.toUpperCase())
	)
}

let PrettierConf = undefined
try {
	const require = createRequire(import.meta.url)
	// TODO - this doesn't work. perhaps this should be an argument too?
	const confPath = require.resolve('@sofie-automation/code-standard-preset/.prettierrc.json')
	PrettierConf = JSON.parse(await fs.readFile(confPath))
} catch (e) {
	console.log(e)
	console.warn(`Failed to resolve prettier config path, skipping prettier formatting`)
}

const basePath = path.resolve(searchPath)
const resolvedOutputPath = path.resolve(outputPath)
const dirs = (await fs.readdir(basePath, { withFileTypes: true })).filter((c) => c.isDirectory()).map((d) => d.name)

// Re-create output folder for generated types
await fs.rm(resolvedOutputPath, { recursive: true, force: true })
await fs.mkdir(resolvedOutputPath, { recursive: true })

let indexFile = BANNER + `\n`
let baseMappingsTypes = []

let deviceOptionsFile = BANNER + `\n`
let deviceOptionsTypes = []
let deviceTypeEnum = []

let manifestFileSubdevices = ''
let manifestFileImports = ''

const genericActionTypes = [] // TODO - should this be usable for plugins?
if (isMainRepository) {
	// Perform some special handling for the main repository. Ideally this would be a dedicated script, but that gets complicated due to needing to share the `genericActionTypes` array with the latter parts of this script

	deviceOptionsFile += `import type { DeviceOptionsBase } from '../device'\n`

	// convert action-schema
	try {
		const actionSchemaDescr = JSON.parse(
			await fs.readFile('../timeline-state-resolver-api/$schemas/action-schema.json')
		)
		const actionSchema = await compile(actionSchemaDescr.properties.actions.items, 'TSRActionSchema', {
			enableConstEnums: false,
			additionalProperties: false,
			style: PrettierConf,
			bannerComment: '',
		})

		await fs.writeFile('../timeline-state-resolver-types/src/generated/action-schema.ts', BANNER + '\n' + actionSchema)
	} catch (e) {
		console.error('Error while generating action-schema.json, continuing...')
		console.error(e)
		hadError = true
	}

	// convert generic PTZ actions
	try {
		const actionsDescr = JSON.parse(await fs.readFile('./src/$schemas/generic-ptz-actions.json'))
		const actionDefinitions = []
		let output = ''
		for (const action of actionsDescr.actions) {
			let actionTypes = []
			const actionDefinition = {
				id: action.id,
				payloadId: undefined,
				resultId: undefined,
			}
			actionDefinitions.push(actionDefinition)
			// Payload:
			if (action.payload) {
				actionDefinition.payloadId = action.payload.id || capitalise(action.id + 'Payload')
				genericActionTypes.push(actionDefinition.payloadId)
				actionTypes.push(
					await compile(action.payload, actionDefinition.payloadId, {
						additionalProperties: false,
						style: PrettierConf,
						bannerComment: '',
						enableConstEnums: false,
					})
				)
			}
			// Return Data:
			if (action.result) {
				actionDefinition.resultId = action.result.id || capitalise(action.id + 'Result')
				genericActionTypes.push(actionDefinition.resultId)
				actionTypes.push(
					await compile(action.result, actionDefinition.resultId, {
						additionalProperties: false,
						style: PrettierConf,
						bannerComment: '',
						enableConstEnums: false,
					})
				)
			}
			output += '\n' + actionTypes.join('\n')
		}

		await fs.writeFile('../timeline-state-resolver-types/src/generated/generic-ptz-actions.ts', BANNER + '\n' + output)
	} catch (e) {
		console.error('Error while generating common-options.json, continuing...')
		console.error(e)
	}

	// convert common-options
	try {
		const commonOptionsDescr = JSON.parse(await fs.readFile('./src/$schemas/common-options.json'))
		const commonOptionsSchema = await compile(commonOptionsDescr, 'DeviceCommonOptions', {
			additionalProperties: false,
			style: PrettierConf,
			bannerComment: '',
			enableConstEnums: false,
		})

		await fs.writeFile(
			'../timeline-state-resolver-types/src/generated/common-options.ts',
			BANNER + '\n' + commonOptionsSchema
		)
	} catch (e) {
		console.error('Error while generating common-options.json, continuing...')
		console.error(e)
		hadError = true
	}

	// Inject the generated types into the index.ts file
	indexFile += `export * from './action-schema'
export * from './generic-ptz-actions'
export * from './device-options'
`
}

// iterate over integrations
for (const dir of dirs) {
	const dirPath = path.join(basePath, dir)

	// Avoid deferencing recursively
	if (dirPath.startsWith(resolvedOutputPath)) continue

	const dirId = capitalise(dir)

	let output = ''

	// compile options from file
	try {
		const filePath = path.join(dirPath, 'options.json')
		if (await fsExists(filePath)) {
			const optionsDescr = JSON.parse(await fs.readFile(filePath))
			delete optionsDescr.title // remove the title, so the generation uses the forced one
			const options = await compile(optionsDescr, dirId + 'Options', {
				additionalProperties: false,
				style: PrettierConf,
				bannerComment: '',
				enableConstEnums: false,
			})
			output += '\n' + options
		}
	} catch (e) {
		console.error('Error while generating options for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	let hasMappingsSchema = false

	// compile mappings from file
	const mappingIds = []
	try {
		const filePath = path.join(dirPath, 'mappings.json')
		hasMappingsSchema = await fsExists(filePath)
		if (hasMappingsSchema) {
			const mappingDescr = JSON.parse(await fs.readFile(filePath))
			for (const [id, mapping] of Object.entries(mappingDescr.mappings)) {
				mappingIds.push(id)

				// Perform some tweaks of the schema for mappingType, which is required to be defined based on the id
				mapping.title = `Mapping${dirId}${capitalise(id)}`
				mapping.properties['mappingType'] = {
					type: 'constant',
					tsType: `Mapping${dirId}Type.${capitalise(id)}`,
				}

				if (!mapping.required) mapping.required = []
				if (!mapping.required.includes('mappingType')) mapping.required.push('mappingType')

				const mappingTypes = await compile(mapping, id + 'Mapping', {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
					enableConstEnums: false,
				})
				output += '\n' + mappingTypes
			}
		}
	} catch (e) {
		console.error('Error while generating mappings for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	// very crude way to create an enum and union for the mappings:
	const mappingTypes = []
	if (mappingIds.length > 0) {
		let mappingsEnum = 'export enum Mapping' + dirId + 'Type {\n'
		for (const id of mappingIds) {
			mappingTypes.push(`Mapping${dirId}${capitalise(id)}`)
			mappingsEnum += '\t' + capitalise(id) + " = '" + id + "',\n"
		}
		mappingsEnum += '}\n'

		output += '\n' + mappingsEnum
	}

	const someMappingName = `SomeMapping${dirId}`
	baseMappingsTypes.push(someMappingName)
	output += '\n' + `export type ${someMappingName} = ${mappingTypes.join(' | ') || 'Record<string, never>'}\n`

	// compile actions from file
	const actionDefinitions = []
	const importGenericTypes = new Set()

	let hasActionsSchema = false

	try {
		const filePath = path.join(dirPath, 'actions.json')
		hasActionsSchema = await fsExists(filePath)
		if (hasActionsSchema) {
			const actionsDescr = JSON.parse(await fs.readFile(filePath))
			for (const action of actionsDescr.actions) {
				const actionDefinition = {
					id: action.id,
					payloadId: undefined,
					resultId: undefined,
				}
				actionDefinitions.push(actionDefinition)
				if (action.generic) continue

				const actionTypes = []
				// Payload:
				if (action.payload) {
					actionDefinition.payloadId = action.payload.id || capitalise(action.id + 'Payload')
					if (genericActionTypes.includes(actionDefinition.payloadId)) {
						importGenericTypes.add(actionDefinition.payloadId)
					} else {
						actionTypes.push(
							await compile(action.payload, actionDefinition.payloadId, {
								additionalProperties: false,
								style: PrettierConf,
								bannerComment: '',
								enableConstEnums: false,
							})
						)
					}
				}
				// Return Data:
				if (action.result) {
					actionDefinition.resultId = action.result.id || capitalise(action.id + 'Result')
					if (genericActionTypes.includes(actionDefinition.resultId)) {
						importGenericTypes.add(actionDefinition.resultId)
					} else {
						actionTypes.push(
							await compile(action.result, actionDefinition.resultId, {
								additionalProperties: false,
								style: PrettierConf,
								bannerComment: '',
								enableConstEnums: false,
							})
						)
					}
				}

				if (actionTypes.length) {
					output += '\n' + actionTypes.join('\n')
				}
			}
		}
	} catch (e) {
		console.error('Error while generating actions for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	if (importGenericTypes.size > 0) {
		output = `import type { ${Array.from(importGenericTypes).join(', ')} } from './generic-ptz-actions'\n\n` + output
	}

	if (actionDefinitions.length > 0) {
		// An enum for all action ids:

		output += `
export enum ${dirId}Actions {
${actionDefinitions
	.map((actionDefinition) => `\t${capitalise(actionDefinition.id)} = '${actionDefinition.id}'`)
	.join(',\n')}
}`
		// An interface for all the action methods:
		output += `
export interface ${dirId}ActionMethods {
${actionDefinitions
	.map(
		(actionDefinition) =>
			`\t[${dirId}Actions.${capitalise(actionDefinition.id)}]: (payload: ${
				actionDefinition.payloadId ? actionDefinition.payloadId : 'Record<string, never>'
			}) => Promise<ActionExecutionResult<${actionDefinition.resultId || 'void'}>>`
	)
	.join(',\n')}
}
`
		// Prepend import:
		output =
			`import type { ActionExecutionResult } from "${
				isMainRepository ? '../actions' : 'timeline-state-resolver-types'
			}"\n` + output
	}

	output += `
export interface ${dirId}DeviceTypes {
	Options: ${dirId}Options
	Mappings: SomeMapping${dirId}
	Actions: ${actionDefinitions.length > 0 ? `${dirId}ActionMethods` : 'null'}
}
`

	let deviceTypeId = toConstantCase(dir)
	// Special case handling for some devices, for backwards compatibility
	if (
		deviceTypeId === 'CASPAR_CG' ||
		deviceTypeId === 'HTTP_SEND' ||
		deviceTypeId === 'HTTP_WATCHER' ||
		deviceTypeId === 'TCP_SEND' ||
		deviceTypeId === 'VIZ_MSE'
	) {
		deviceTypeId = dir.toUpperCase()
	}
	deviceTypeEnum.push(deviceTypeId)

	deviceOptionsFile += `import type { ${dirId}Options } from './${dir}'
export interface DeviceOptions${dirId} extends DeviceOptionsBase<${dirId}Options> {
	type: DeviceType.${deviceTypeId}
}\n\n`
	deviceOptionsTypes.push(`DeviceOptions${dirId}`)

	manifestFileSubdevices += `\t\t[DeviceType.${deviceTypeId}]: {
			displayName: generateTranslation('${toTitleCase(dirId)}'),\n`

	if (hasActionsSchema) {
		manifestFileImports += `import ${dirId}Actions = require('./$schemas/generated/${dir}/actions.json')\n`
		manifestFileSubdevices += `\t\t\tactions: ${dirId}Actions.actions.map(stringifyActionSchema),\n`
	}
	manifestFileImports += `import ${dirId}Options = require('./$schemas/generated/${dir}/options.json')\n`
	manifestFileSubdevices += `\t\t\tconfigSchema: JSON.stringify(${dirId}Options),\n`

	if (hasMappingsSchema) {
		manifestFileImports += `import ${dirId}Mappings = require('./$schemas/generated/${dir}/mappings.json')\n`
		manifestFileSubdevices += `\t\t\tmappingsSchemas: stringifyMappingSchema(${dirId}Mappings),\n`
	} else {
		manifestFileSubdevices += `\t\t\tmappingsSchemas: {},\n`
	}

	manifestFileSubdevices += `\t\t},\n`

	// Output to tsr types package
	const outputFilePath = path.join(resolvedOutputPath, dir + '.ts')
	if (output) {
		output = BANNER + output

		await fs.writeFile(outputFilePath, output)

		indexFile += `\nexport * from './${dir}'`
		indexFile += `\nimport type { ${someMappingName} } from './${dir}'`
		indexFile += '\n'
	} else {
		if (await fsUnlink(outputFilePath)) console.log('Removed ' + outputFilePath)
	}
}

if (baseMappingsTypes.length) {
	indexFile += `\nexport type TSRMappingOptions =\n\t| ${baseMappingsTypes.join('\n\t| ')}`
}

// Output the tsr-types index file
await fs.writeFile(path.join(resolvedOutputPath, 'index.ts'), indexFile + '\n')

if (isMainRepository) {
	deviceOptionsFile += `export type DeviceOptionsAny =\n\t| ${deviceOptionsTypes.join('\n\t| ')}\n\n`

	deviceOptionsFile += `/**
 * An identifier of a particular device class
 *
 * @export
 * @enum {string}
 */
export enum DeviceType {\n\t${deviceTypeEnum.map((type) => `${type} = '${toConstantCase(type)}'`).join(',\n\t')}\n}\n`

	await fs.writeFile(path.join(resolvedOutputPath, 'device-options.ts'), deviceOptionsFile + '\n')

	let manifestFile =
		BANNER +
		`
import { DeviceType } from 'timeline-state-resolver-types'
import CommonOptions = require('./$schemas/common-options.json')
import { generateTranslation } from './lib'
import { stringifyActionSchema, stringifyMappingSchema, TSRManifest } from './manifestLib'
`
	manifestFile += manifestFileImports + '\n'
	manifestFile += `export const builtinDeviceManifest: TSRManifest = {
	commonOptions: JSON.stringify(CommonOptions),
	subdevices: {
${manifestFileSubdevices}
	},
}`
	await fs.writeFile('../timeline-state-resolver/src/manifest.ts', manifestFile + '\n')
}

// Finally
process.exit(hadError ? 1 : 0)

async function fsExists(filePath) {
	try {
		await fs.access(filePath, fs.F_OK)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false
		throw e
	}
}
async function fsUnlink(filePath) {
	try {
		await fs.unlink(filePath)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false // File doesn't exist, that's okay
		throw e
	}
}
